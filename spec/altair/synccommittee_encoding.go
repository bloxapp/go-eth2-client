// Code generated by fastssz. DO NOT EDIT.
package altair

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the SyncCommittee object
func (s *SyncCommittee) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncCommittee object to a target array
func (s *SyncCommittee) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'PubKeys'
	if len(s.PubKeys) != 1024 {
		err = ssz.ErrVectorLength
		return
	}
	for ii := 0; ii < 1024; ii++ {
		dst = append(dst, s.PubKeys[ii][:]...)
	}

	// Field (1) 'PubKeyAggregates'
	if len(s.PubKeyAggregates) != 16 {
		err = ssz.ErrVectorLength
		return
	}
	for ii := 0; ii < 16; ii++ {
		dst = append(dst, s.PubKeyAggregates[ii][:]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SyncCommittee object
func (s *SyncCommittee) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 49920 {
		return ssz.ErrSize
	}

	// Field (0) 'PubKeys'
	s.PubKeys = make([]BLSPubKey, 1024)
	for ii := 0; ii < 1024; ii++ {
		copy(s.PubKeys[ii][:], buf[0:49152][ii*48:(ii+1)*48])
	}

	// Field (1) 'PubKeyAggregates'
	s.PubKeyAggregates = make([]BLSPubKey, 16)
	for ii := 0; ii < 16; ii++ {
		copy(s.PubKeyAggregates[ii][:], buf[49152:49920][ii*48:(ii+1)*48])
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncCommittee object
func (s *SyncCommittee) SizeSSZ() (size int) {
	size = 49920
	return
}

// HashTreeRoot ssz hashes the SyncCommittee object
func (s *SyncCommittee) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncCommittee object with a hasher
func (s *SyncCommittee) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'PubKeys'
	{
		if len(s.PubKeys) != 1024 {
			err = ssz.ErrVectorLength
			return
		}
		subIndx := hh.Index()
		for _, i := range s.PubKeys {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'PubKeyAggregates'
	{
		if len(s.PubKeyAggregates) != 16 {
			err = ssz.ErrVectorLength
			return
		}
		subIndx := hh.Index()
		for _, i := range s.PubKeyAggregates {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}
